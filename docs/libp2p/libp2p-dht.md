---
description: Describing the libp2p Distributed Hash Table
---

# The Distributed Hash Table

## Introduction

The Kademlia Distributed Hash Table is used in libp2p to provide _peer discovery_ and _content routing_.
In simple terms, a hash table is a set of records in which every record holds a `key -> value` mapping.
In a distributed hash table, the records are distributed across the network, which means that every node holds a subset of records.

When searching for a specific record, we do not have a centralized registry, therefore, must ask our peers for their subset of the DHT, and our peers must do the same subsequently until the record is found.

// image

The libp2p DHT is based on the Kademlia DHT, so it incorporates most of its core concepts with some extra functionalities. Nodes communicate by using an RPC protocol over UDP. The operations provided by the protocol are:

- Peer discovery (`findNode(peerId string)`): given a peer ID, find out where it is located.
- Adding value: inserting a record of the form `key -> value`
- Find a value by its key: finding the value in the DHT for a given key.
- Add provider: advertising in the network that a peer is providing a given key.
- Get providers: finding out what peers provide the value for the given key.

### Peer discovery

_Discovering a peer_ means finding its location (multiaddress) by using its peer ID. For example, if you have a peer ID ``, you want to know how to reach that node (IP address, port...).

Every peer holds a list of peer IDs that are _close_, along with their multiaddresses. The concept of _closeness_ in the DHT is not trivial, and it is covered later in this lecture. For now, consider that we can know if two peers are close by comparing their IDs.
The _routing table_ is the structure responsible for managing the list of close peers.

To understand it better, think about a function `distance(id1, id2)`, which receives two peer IDs as a parameter and is able to return an integer representing the distance between the peers. For example: `distance(my_id1, my_id2) = 4`, where the distance between the nodes is `4`.

By calculating the distance between two peers, we can select the _best_ close peers and subsequently approach the target peer. To explain the process of finding a peer, consider the following diagram.

// image

Every peer has a parameter, _dist_, which represents the distance from the peer to the target peer (`Peer 10`). For example, `Peer 5` with `dist = 10` means that `distance(peer5_id, peer10_id) = 5`.
The arrows represent the neighbors of every peer.

Now consider the following diagram, which illustrates the steps of the peer discovery.

// image

You are in `Peer 1`, and you want to get to `Peer 10`. The traversal of nodes will be:
1. `Peer 1` has three close nodes. For every node, a `find_node` request is sent.
The response gives information about the peer's distance to `Peer 10`, and the peer's close nodes.
`Peer 2` and `Peer 3` are selected because they have the lowest distance to `Peer 10`.
2. From `Peer 1`, a `find_node` request is sent to the close nodes of `Peer 2` and `Peer 3` (i.e. `Peer 5`, `Peer 6`, `Peer 7`, `Peer 8`).
The nodes with the lowest distance to `Peer 10` are selected: `Peer 6` and `Peer 7`.
3. From `Peer 1`, a `find_node` request is sent to `Peer 9` and `Peer 10`.
`Peer 10`'s distance is `0`, therefore, we have found the target peer.

Note that all the requests are made from `Peer 1`. The starting node is responsible for managing all the requests.

Some nodes might have hundreds of neighbors, so sending a request to all the neighbors of a peer could lead to performance issues. To avoid this, there is usually a limit, `k`, which you can select. In the previous example, `k = 2`.

### The Distance Metric

In the DHT, _distance_ does not necessarily refer to geographical distance. The distance between two peers is calculated as the `XOR` of their peer IDs (`distance(my_id1, my_id2) = XOR(my_id1, my_id2)`). Then, the result is converted into an integer.

### Put value

_Putting a value_ means creating a mapping of the form `key -> value` in the DHT. For every key, an ID is generated by using the same format as peer IDs. While peer IDs are usually random, key IDs are generated from the key itself.

Having an ID for every key in the same format as peer IDs means that we can calculate _distances_ between key IDs and peer IDs. When putting a value, the following process occurs:

1. Generate an ID for the key: `key_id`.
2. Find the _k_ closest nodes to the key ID. This means that every close node (until a limit _k_) is asked to provide its distance to the key ID (i.e. `distance(peer_id, key_id)`). The `find_node` function is used.
3. The `key -> value` record is stored in every close node.

This means that there will be **several nodes storing the same record**, which can lead to inconsistencies at some point. Validation strategies are applied.

Although both peers and keys share the same ID format, peer IDs are not part of the keys. Instead, a peer, with a given peer ID, holds a set of keys.

### Get value

To get a value from a key, we should find the peers holding the given key. Previously, we mention that peer and key IDs have the same format. Because keys are stored in peers with similar IDs, we can consider that finding a node with `peer_id = key_id` will take us to a peer that holds the key.

Therefore, the search is really a **peer discovery** traversal where we want to get to a hypothetical node with the same ID as the key. In every iteration of the search, we compute the distance `distance(peer_id, key_id)`.

For a given key, we will get values from different peers, which might be inconsistent at some point. If all the values are not the same, then we must implement a consensus strategy (for example, we accept the value provided by the majority).

In storage systems (e.g. IPFS), a key of the DHT might represent the CID of a specific file. Therefore, searching for a specific key means finding what peers hold a specific file. 

## Expand Your Knowledge



