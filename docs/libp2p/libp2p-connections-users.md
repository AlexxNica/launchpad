---
description: How libp2p Routes Content to Connect Users
---

# libp2p Connections and Users

## Understanding nodes

Although libp2p was originally developed to work with IPFS, you can use it to create p2p applications that have no relationship to IPFS at all. The modularity of libp2p allows you to take whichever pieces you need in your project.

A central term in a p2p network is the _node_. The concept of a _node_ is pretty broad in software engineering, but in libp2p, it usually refers to a single _peer_ of the network (essentially, a computer that might send or receive messages within the p2p network).

For example, in the following snippet, `libp2p-go` (the Go implementation of libp2p), is used to create a node with default settings.

```go
import (
    libp2p "github.com/libp2p/go-libp2p"
)

func main() {
    host, err := libp2p.New()
    if err != nil {
        panic(err)
    }
}
```

Nodes establish connections with other nodes, so we need a way to locate those nodes. With peer identifiers and multiaddresses, you can locate nodes to connect with.

### Peer Identity

Every node in the network is uniquely identified through its _peer id_. A peer id is generated from the public key of the node.
A peer id is a multihash, which essentially is a hash prefixed with the hash algorithm used (the same way that multihashes are used in CIDs).

If the public key's length is more than 48 bytes, then the multihash digest is generated by applying a hash function to the public key.
If the public key's length is less than 48 bytes, then the multihash digest is the public key itself, and the 
hash function code is the _identity code_. The identity code means that no has been applied to the digest.

![How peer IDs are generated](<../../.gitbook/assets/libp2p-peer-identity.png>)

### Multiaddress

We have every node uniquely identified by its public key, however, we still must know _where_ and _how_ to establish the connection.
A multiaddress allows you to specify the transport for the connection (TCP, UDP, QUIC...) and network to establish that connection (IP, DNS...).

The following example specifies a connection to the `127.0.0.1` IPv4 by using the UDP protocol at port 1234.

```
/ip4/127.0.0.1/udp/1234
```

The main advantage of multiaddresses is that they are self-describing. Only by looking at the address, you can figure out what protocols are involved in the connection.

### Establishing a connection

Now that we know how to reach our peers, we can create a connection. When we create a connection in libp2p, a process called _connection bootstrapping_ occurs. This process is responsible for:

1. Handshake: establish the _raw_ connection with the peer.
2. Security protocol: negotiate the security protocol for the raw connection (e.g. TLS).
3. Stream multiplexer: negotiate the stream multiplexer protocol.

Note that libp2p does **NOT** allow connections that are not secured or multiplexed.
When establishing the connection, we will have two actors: the initiator and the responder.

#### Handshake

The handshake starts the connection with the peer and verifies that the peer can understand the `multistream-set` protocol.

After the handshake, the two peers must negotiate other protocols (security, multiplexer, application...), so we need a protocol that indicates how two peers can negotiate other protocols. The Multistream protocol allows peers to exchange what other protocols they support and negotiate them. Therefore, both peers must talk over the same version of Multistreams.

```shell
# Request: Do you understand "multistream 1.0.0"?
> multistream 1.0.0

# Response: I do.
+ multistream 1.0.0
```

#### Security

Now, the two peers will use Multistream to negotiate the security protocol, which allows the connection to be encrypted.

Usually, several protocols are tried during the negotiation, with a preference order. For example, you might try to use TLS first. If your peer does not support TLS, you might try Noise. When a security protocol is accepted, the connection is upgraded to use that protocol.

```shell
# Request: Do you understand "TLS 1.0.0"?
> multistream 1.0.0

# Response: I do not
+ na

# Request: Do you understand "noise 1.0.0"?
> noise 1.0.0

# Response: I do
+ noise 1.0.0
```

#### Multiplexer

Once the connection is secured, a multiplexer protocol is negotiated. Muxtiplexing means allowing several protocols through a single connection. For example, if your peer wants to consume both TCP and UDP, the same connection will be used, instead of creating a connection for each protocol. Multiplexing is important because creating connections is expensive.

Because the data will be sent over the same connection, we need an abstraction called _stream_. A stream represents the data for a specific protocol in a given connection. For example, if your connection exposes TCP and UDP protocols, then two streams will be created. Data flowing through the connection is assigned its corresponding _stream id_.

![Streams in a single connection](<../../.gitbook/assets/libp2p-streams.png>)

### Negotiating protocols

After the connection is established (i.e. handshake, security, and multiplexing), peers exchange what protocols they support. The Multistream protocol is used to ask for a list of supported protocols (`multistream ls`).

By default, this is done after the connection is established, but the Multistream list function can be used later to verify if new protocols have been added.

Every supported protocol is assigned a handler function, which manages the data for that protocol.

### Peer Discovery

Every peer has an identifier, which is generated from its public key. However, this is not enough to find out the location of the peer. Libp2p exposes two interfaces: Advertiser and Discoverer.

The Advertiser offers services to the network, which means that shares the protocols that it supports with the rest of the network. On the other hand, the Discoverer is able to find peers.

The are two main implementations: mDNS and the Kademlia Distributed Hash Table. The Kademlia DHT is used to discover peers in the IPFS network. Other implementations are also valid as long as they comply with the previously mentioned interfaces.

**The Life of a libp2p Connection | Jacob Heun**

{% embed url="https://www.youtube.com/watch?v=zcWHamr5m_k" %}

## libp2p Users

The users of the libp2p protocol suite include, and is a list that is always being added to:

* [Prysmaticlabs.com](http://prysmaticlabs.com)
* [onflow.org](http://onflow.org)
* [minaprotocol.com](http://minaprotocol.com)
* [polygon.technology](http://polygon.technology)
* [celestia.org](http://celestia.org)
* [elrond.com](http://elrond.com)
* [0x.org](http://0x.org)
* [filecoin.io](http://filecoin.io)
* [ipfs.io](http://ipfs.io)
* [ethereum.org](https://ethereum.org/en/eth2/)
* [polkadot.network](https://polkadot.network)
